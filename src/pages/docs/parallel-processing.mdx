import { Callout, Steps } from 'nextra/components'

# Parallel Processing Documentation

Documentation for `thread.ParallelProcessing`.



## Why Parallel Processing?

Parallel Processing is used to speed up the data processing of large datasets by splitting workflow into multiple threads.

Traditionally, this is achieved with a for loop.
```py
my_dataset = [] # Large dataset
def my_data_processor(Data_In) -> Data_Out:
  ...

processed_data = []
for data in my_dataset:
  processed_data = my_data_processor(data)

print(processed_data) # Processed data
```

While this is simple and decent enough for a small dataset, this is not ideal for large datasets, especially when runtime matters.
By using `thread.ParallelProcessing` we can split the large dataset into multiple chunks and process each chunk simultaneously.

<Callout>
  Parallel Processing is not True Parallel.
  Learn more [here](/learn/cautions/parallelism).
</Callout>



## How It Works

<Steps>

  ### Determine Thread Count

  The number of threads used is determined by the following formula:
  ```py
  thread_count = min(max_threads, len(dataset))
  ```

  This ensures that the number of threads used will always be less than or equal to the length of the dataset,
  which prevents redundant threads to be initialized for small datasets.

  ### Chunking

  The dataset is split as evenly as possible into chunks, preserving the order of data.
  Chunks follow the structure:
  ```py
  chunks = [[1, 2, 3, ...], [50, 51, 52, ...], ...]
  ```

  Let $N$ be the length of the dataset
  and let $M$ be the number of threads.

  The individual chunk lengths decrease down the chunk list.
  The length of each chunk will can be either $\lfloor{N/M + 0.5}\rfloor + 1$ or $N/M$.

  <Callout type='warning'>
    The chunks generated are not generators, meaning they will exist alongside `dataset` and take up memory.
    This will change to more memory-efficient generators in `v1.0.1`.
  </Callout>

</Steps>



## Importing the class

```py
import thread
thread.ParallelProcessing

from thread import ParallelProcessing
```



## Quick Start

A simple example
```py
def my_data_processor(Data_In) -> Data_Out: ...

# Reccommended way
my_processor = ParallelProcessing(
  function = my_data_processor,
  dataset = [i in range(0, n)]
)

# OR
# Not the reccommended way
my_processor = ParallelProcessing(my_data_processor, [i in range(0, n)])
```

It can be ran by invoking the `start()` method
```py
my_processor.start()
```

<Callout type="info">
  The **threading.ParallelProcessing()** class from python will only be initialized when **start()** is invoked
</Callout>



### Parameters

* function : (DataProcessor, dataset, *args, **kwargs) -> Any | Data_Out
  > This should be a function that takes in a dataset and/or anything and returns Data_Out and/or anything

* dataset : Sequence[Data_In] = ()
  > This should be an interable sequence of arguments parsed to the `DataProcessor` function<br />
  > (e.g. tuple('foo', 'bar'))
  
* *overflow_args : Overflow_In
  > These are arguments parsed to [**thread.Thread**](./threading.md#parameters)

* **overflow_kwargs : Overflow_In
  > These are arguments parsed to [**thread.Thread**](./threading.md#parameters)<br />
  <Callout type="info">
    If `args` is present, then it will automatically be removed from kwargs and joined with `overflow_args`
  </Callout>
  

* **Raises** AssertionError: max_threads is invalid



### Attributes

These are attributes of [`ParallelProcessing`](#importing-the-class) class

* results : List[Data_Out]
  > The result value<br />
  > **Raises** [`ThreadNotInitializedError`](./exceptions.md#threadNotInitializedError)<br />
  > **Raises** [`ThreadNotRunningError`](./exceptions.md#threadnotrunningerror)<br />
  > **Raises** [`ThreadStillRunningError`](./exceptions.md#threadStillRunningError)



### Methods

These are methods of [`ParallelProcessing`](#importing-the-class) class

* start : () -> None
  > Initializes the threads and starts it<br />
  > **Raises** [`ThreadStillRunningError`](./exceptions.md#threadStillRunningError)

* is_alive : () -> bool
  > Indicates whether the thread is still alive<br />
  > **Raises** [`ThreadNotInitializedError`](./exceptions.md#threadNotInitializedError)

* get_return_values : () -> Data_Out
  > Halts the current thread execution until the thread completes

* join : () -> JoinTerminatedStatus
  > Halts the current thread execution until a thread completes or exceeds the timeout<br />
  > **Raises** [`ThreadNotInitializedError`](./exceptions.md#threadNotInitializedError)<br />
  > **Raises** [`ThreadNotRunningError`](./exceptions.md#threadnotrunningerror)

* kill : (yielding: bool = False, timeout: float = 5) -> bool
  > Schedules the thread to be killed<br />
  > If yielding is True, it halts the current thread execution until the thread is killed or the timeout is exceeded<br />
  > **Raises** [`ThreadNotInitializedError`](./exceptions.md#threadnotinitializederror)<br />
  > **Raises** [`ThreadNotRunningError`](./exceptions.md#threadnotrunningerror)<br />
  <Callout type="info">
    This only schedules the thread to be killed, and does not immediately kill the thread
  </Callout>

Now you know how to use the [`ParallelProcessing`](#importing-the-class) class!

[See here](./parallel-processing.md) for how to using the `thread.ParallelProcessing` class!