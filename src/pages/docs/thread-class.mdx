import { Callout } from 'nextra/components'


export function Argument({ title, ofType, defaultValue = false, open = false, children }) {return (
  <details
    id={title}
    open={open}
    className="last-of-type:mb-0 rounded-lg bg-neutral-50 dark:bg-neutral-800 p-2 mt-4"
  >
    <summary>
      <strong className="text-lg">
        {title}: <span className="ml-4 text-neutral-500">{ofType}</span> {defaultValue && <span className="ml-4 text-neutral-500">(default: {defaultValue})</span>}
      </strong>
    </summary>
    <div className="nx-p-2">{children}</div>
  </details>
)}



# Thread Class Documentation

Documentation for `thread.Thread`.


## Importing the class

Here are some ways of importing the `Thread` class.

```python
import thread
thread.Thread

from thread import Thread
```



## Quick Start

There are main 2 ways of initializing a thread.

### On-Demand
You can create a simple thread by initializing `thread.Thread` and parsing the `target` function.
```python
def my_target(): ...

# Recommended way
my_thread = Thread(
  target = my_target
)

# OR
# Not the recommended way
my_thread = Thread(my_target)
```

A thread can be ran by invoking the `start()` method
```py
my_thread.start()
```

### Decoratored Function
You can decorate a function with `thread.threaded` which uses `thread.Thread`.
When the decorated function is invoked, it will automatically be ran in a new thread each time and return a `thread.Thread` object.

```python
import thread

@thread.threaded
def my_target(): ...

worker = my_target() # thread.Thread()
```

<Callout type='info'>
  Did you know?

  Decorators can take in keyword arguments that change the behavior of the thread.
  ```py
  import thread

  @thread.threaded(name = 'my_thread', suppress_errors = True)
  def my_target(): ...
  ```

  See the full list of arguments [here](#initialization)

</Callout>



## Initialization

This will cover the required and optional arguments initializing a thread.

### Required

<Argument title='target' ofType='(*args, **kwargs) -> Data_Out'>
  This should be a function which takes in any arguments and returns anything.

  Any arguments and keyword arguments parsed to the `target` function can be parsed through `args` and `kwargs`.
  `Data_Out` will be written to `Thread._returned_value` and can be accessed via `Thread.result` or `Thread.get_return_value()`.

  `target` can be parsed as the first argument to `Thread.__init__()`, although it is recommended to use only keyword arguments.
  ```py
  import thread

  thread.Thread(lambda x: x + 1)
  thread.Thread(target = lambda x: x + 1)
  ```

  <Callout type='info'>
    Best Practices

    While you can use a lambda function, it is best to use a normal function for your LSP/Linter to infer types.
    ```py
    from thread import Thread

    worker = Thread(target = lambda x: x + 1)
    worker.start()
    worker.join()

    worker.result # This will be inferred as Unknown by your LSP/Linter
    ```
    ```py
    from thread import Thread

    def my_target(x: int) -> int:
      return x + 1

    worker = Thread(target = my_target)
    worker.start()
    worker.join()

    worker.result # This will be inferred as int
    ```
  </Callout>
</Argument>


### Optional

<Argument title='args' ofType='Sequence[Data_In]' defaultValue='()'>
  This should be an iterable sequence of arguments parsed to the `target` function.

  For example:
  ```py
  import thread

  thread.Thread(target = my_target, args = ('foo', 'bar'))
  thread.Thread(target = my_target, args = ['foo', 'bar'])
  ```

  <Callout type='warning'>
    Args used in `Thread.__init__()` cannot offer static type checking. [Learn More](/learn/cautions/type-safety)
  </Callout>
</Argument>

<Argument title='kwargs' ofType='Mapping[str, Data_In]' defaultValue='{}'>
  This should be a mapping of kwargs passed to the `target` function.

  For example:
  ```py
  import thread

  thread.Thread(target = my_target, kwargs = {'foo': 'bar'})
  thread.Thread(target = my_target, kwargs = dict(foo = 'bar'))
  ```

  <Callout type='warning'>
    Kwargs used in `Thread.__init__()` cannot offer static type checking. [Learn More](/learn/cautions/type-safety)
  </Callout>
</Argument>

<Argument title='ignore_errors' ofType='Sequence[type[Exception]]' defaultValue='()'>
  This should be an iterable sequence of all types of exceptions to ignore.
  Ignored errors are not propagated or logged to `Thread.errors`.

  The `Exception` class can be parsed to ignore all exceptions.

  For example:
  ```py
  import thread

  # This ignores all exceptions
  # thread.errors = []
  # hooks begin execution
  thread.Thread(target = raiseRuntimeError, ignore_errors = (Exception,))

  # This propagates the exception
  # thread.errors = [RuntimeError]
  # thread is killed
  thread.Thread(target = raiseRuntimeError, ignore_errors = [TypeError])

  # This ignores RuntimeError
  # thread.errors = []
  # hooks begin execution
  thread.Thread(target = raiseRuntimeError, ignore_errors = [RuntimeError])
  ```

  <Callout type='info'>
    Ignored exceptions may cause unintended skipped code execution.
    ```py
    import thread

    def my_target():
      print('Before raise')
      raise Exception('oh no!')
      print('After raise')

    thread.Thread(target = my_target, ignore_errors = (Exception,))
    thread.start()

    # > Before raise
    # Program End
    ```
  </Callout>
</Argument>

<Argument title='suppress_errors' ofType='bool' defaultValue='False'>
  This should be a boolean indicating whether non-ignored exceptions will be propagated.

  <Callout type='info'>
    Non-ignored exceptions will be logged to `Thread.errors` without propagating.
  </Callout>

  ```py
  import thread

  # Thread.errors = [RuntimeError]
  # hooks begin execution
  thread.Thread(target = raiseRuntimeError, suppress_errors = True)
  ```
</Argument>

<Argument title='name' ofType='str' defaultValue='None'>
  This should be a string name of the thread.

  **_By default, a unique name is constructed of the form "Thread-N" where N is a small decimal number, or "Thread-N (target)" where "target" is target.\_\_name\_\_ if the target argument is specified._**
  ~ Python threading docs.

  ```py
  import thread

  thread.Thread(target = my_target, name = 'my_thread')
  ```

  See [`threading` documentation](https://docs.python.org/3/library/threading.html#threading.Thread) for more details.
</Argument>

* daemon : bool = False
  > This is an argument parsed to `threading.Thread`

* group : None = None
  > This is an argument parsed to `threading.Thread`<br />

  <Callout type="info">
    This does nothing
  </Callout>

* *overflow_args : Overflow_In
  > These are arguments parsed to `threading.Thread`

* **overflow_kwargs : Overflow_In
  > These are arguments parsed to `threading.Thread`



### Attributes

These are attributes of [`Thread`](#importing-the-class) class

* result : Data_Out
  > The result value of the thread
  > **Raises** [`ThreadNotInitializedError`](./exceptions.md#threadNotInitializedError)<br />
  > **Raises** [`ThreadNotRunningError`](./exceptions.md#threadnotrunningerror)<br />
  > **Raises** [`ThreadStillRunningError`](./exceptions.md#threadStillRunningError)

* status : str
  > The current status of the thread



### Methods

These are methods of [`Thread`](#importing-the-class) class

* start : () -> None
  > Initializes the thread and starts it<br />
  > **Raises** [`ThreadStillRunningError`](./exceptions.md#threadStillRunningError)

* is_alive : () -> bool
  > Indicates whether the thread is still alive<br />
  > **Raises** [`ThreadNotInitializedError`](./exceptions.md#threadNotInitializedError)

* add_hook : ((Data_Out) -> Any | None) -> None
  > Hooks will be automatically invoked after a thread successfully completes, parsing the return value as the first argument<br />
  > **Raises** [`ThreadNotInitializedError`](./exceptions.md#threadNotInitializedError)<br />
  > **Raises** [`ThreadNotRunningError`](./exceptions.md#threadnotrunningerror)

* get_return_value : () -> Data_Out
  > Halts the current thread execution until the thread completes

* join : () -> JoinTerminatedStatus
  > Halts the current thread execution until a thread completes or exceeds the timeout<br />
  > **Raises** [`ThreadNotInitializedError`](./exceptions.md#threadNotInitializedError)<br />
  > **Raises** [`ThreadNotRunningError`](./exceptions.md#threadnotrunningerror)

* kill : (yielding: bool = False, timeout: float = 5) -> bool
  > Schedules the thread to be killed<br />
  > If yielding is True, it halts the current thread execution until the thread is killed or the timeout is exceeded<br />
  > **Raises** [`ThreadNotInitializedError`](./exceptions.md#threadnotinitializederror)<br />
  > **Raises** [`ThreadNotRunningError`](./exceptions.md#threadnotrunningerror)<br />
 
  <Callout type="info">
    This only schedules the thread to be killed, and does not immediately kill the thread
  </Callout>



## Behaviours

These are a list of thread behaviors

### Killing Threads - Introduced in v0.1.2

While preferably not utilized, we do support killing threads.<br />
We mark a thread to be killed, and will only be killed when the thread invokes `sys.settrace()`.

<Callout type="warning">
  This means that if your `target` has a long `time.wait()` call, it will only be killed after it moves onto the next line.
</Callout>

Want an alternative? Learn about [Daemonized Threads!](https://www.geeksforgeeks.org/python-daemon-threads/)



### Graceful Exiting - Introduced in v0.1.2

When the program is abruptly stopped with `CTRL+C` for example, active threads will now attempt to gracefully kill itself.<br />

This is not to be an "end-all be-all" for managing threads. You should still try to properly exit a thread before abruptly exiting the program, or utilize a `Daemonized Thread`.

