import { Callout } from 'nextra/components'


export function Argument({ title, ofType, defaultValue = false, open = false, children }) {return (
  <details
    id={title}
    open={open}
    className="last-of-type:mb-0 rounded-lg bg-neutral-50 dark:bg-neutral-800 p-2 mt-4"
  >
    <summary>
      <strong className="text-lg">
        {title}: <span className="ml-4 text-neutral-500">{ofType}</span> {defaultValue && <span className="ml-4 text-neutral-500">(default: {defaultValue})</span>}
      </strong>
    </summary>
    <div className="nx-p-2">{children}</div>
  </details>
)}



# Thread Class Documentation

Documentation for `thread.Thread`.


## Importing the class

Here are some ways of importing the `Thread` class.

```python
import thread
thread.Thread

from thread import Thread
```



## Quick Start

There are main 2 ways of initializing a thread.

### On-Demand
You can create a simple thread by initializing `thread.Thread` and parsing the `target` function.
```python
def my_target(): ...

# Recommended way
my_thread = Thread(
  target = my_target
)

# OR
# Not the recommended way
my_thread = Thread(my_target)
```

A thread can be ran by invoking the `start()` method
```py
my_thread.start()
```

### Decoratored Function
You can decorate a function with `thread.threaded` which uses `thread.Thread`.
When the decorated function is invoked, it will automatically be ran in a new thread each time and return a `thread.Thread` object.

```python
import thread

@thread.threaded
def my_target(): ...

worker = my_target() # thread.Thread()
```

<Callout type='info'>
  Did you know?

  Decorators can take in keyword arguments that change the behavior of the thread.
  ```py
  import thread

  @thread.threaded(name = 'my_thread', suppress_errors = True)
  def my_target(): ...
  ```

  See the full list of arguments [here](#initialization)

</Callout>



## Initialization

This will cover the required and optional arguments initializing a thread.

### Required
### Optional

* ignore_errors : Sequence[type[Exception]] = ()
  > This should be an iterable sequence of all exceptions to ignore.<br />
  > To ignore all exceptions, parse tuple(Exception)

* suppress_errors : bool = False
  > This should be a boolean indicating whether exceptions will be raised.<br />
  > If true, exceptions will only write to internal `errors` property<br />
  > If false, exceptions will propagate if not ignored

* name : Optional[str] = None
  > This is an argument parsed to `threading.Thread`

* daemon : bool = False
  > This is an argument parsed to `threading.Thread`

* group : None = None
  > This is an argument parsed to `threading.Thread`<br />

  <Callout type="info">
    This does nothing
  </Callout>

* *overflow_args : Overflow_In
  > These are arguments parsed to `threading.Thread`

* **overflow_kwargs : Overflow_In
  > These are arguments parsed to `threading.Thread`



### Attributes

These are attributes of [`Thread`](#importing-the-class) class

* result : Data_Out
  > The result value of the thread
  > **Raises** [`ThreadNotInitializedError`](./exceptions.md#threadNotInitializedError)<br />
  > **Raises** [`ThreadNotRunningError`](./exceptions.md#threadnotrunningerror)<br />
  > **Raises** [`ThreadStillRunningError`](./exceptions.md#threadStillRunningError)

* status : str
  > The current status of the thread



### Methods

These are methods of [`Thread`](#importing-the-class) class

* start : () -> None
  > Initializes the thread and starts it<br />
  > **Raises** [`ThreadStillRunningError`](./exceptions.md#threadStillRunningError)

* is_alive : () -> bool
  > Indicates whether the thread is still alive<br />
  > **Raises** [`ThreadNotInitializedError`](./exceptions.md#threadNotInitializedError)

* add_hook : ((Data_Out) -> Any | None) -> None
  > Hooks will be automatically invoked after a thread successfully completes, parsing the return value as the first argument<br />
  > **Raises** [`ThreadNotInitializedError`](./exceptions.md#threadNotInitializedError)<br />
  > **Raises** [`ThreadNotRunningError`](./exceptions.md#threadnotrunningerror)

* get_return_value : () -> Data_Out
  > Halts the current thread execution until the thread completes

* join : () -> JoinTerminatedStatus
  > Halts the current thread execution until a thread completes or exceeds the timeout<br />
  > **Raises** [`ThreadNotInitializedError`](./exceptions.md#threadNotInitializedError)<br />
  > **Raises** [`ThreadNotRunningError`](./exceptions.md#threadnotrunningerror)

* kill : (yielding: bool = False, timeout: float = 5) -> bool
  > Schedules the thread to be killed<br />
  > If yielding is True, it halts the current thread execution until the thread is killed or the timeout is exceeded<br />
  > **Raises** [`ThreadNotInitializedError`](./exceptions.md#threadnotinitializederror)<br />
  > **Raises** [`ThreadNotRunningError`](./exceptions.md#threadnotrunningerror)<br />
 
  <Callout type="info">
    This only schedules the thread to be killed, and does not immediately kill the thread
  </Callout>



## Behaviours

These are a list of thread behaviors

### Killing Threads - Introduced in v0.1.2

While preferably not utilized, we do support killing threads.<br />
We mark a thread to be killed, and will only be killed when the thread invokes `sys.settrace()`.

<Callout type="warning">
  This means that if your `target` has a long `time.wait()` call, it will only be killed after it moves onto the next line.
</Callout>

Want an alternative? Learn about [Daemonized Threads!](https://www.geeksforgeeks.org/python-daemon-threads/)



### Graceful Exiting - Introduced in v0.1.2

When the program is abruptly stopped with `CTRL+C` for example, active threads will now attempt to gracefully kill itself.<br />

This is not to be an "end-all be-all" for managing threads. You should still try to properly exit a thread before abruptly exiting the program, or utilize a `Daemonized Thread`.

